import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

public class PowerGenerator extends ElectricalComponent {
    public int current = 10000; // is public because transformer and circuit braker take power from generator
    public int voltage = 22000;
    private double maxCapacity = 450000000; //W   // correct it with max voltage and current
    protected double powerFactor =  Math.random();
    private double powerFactorCorrected = 0.95;
    private List<LocalDate> mantainanceHist = new ArrayList<>();
    private double Pin = 780 * Math.pow(10, 6); // power out from gas turbine
    CircuitBreaker cb;
    PowerGridController controller;
    protected double activePower = 3 * (this.voltage * this.current * powerFactor); // active and reactive power has been made protected because other grid elements "drain" from
    // generator, but at the same time must be garanteed a certain level of encapsulation so that potential other packages of same project cannot affect instance variables and methods
    double shiftPhaseAngle = Math.toDegrees(Math.acos(powerFactor));
    protected double reactivePower = 3 * (this.voltage * this.current * Math.sin(shiftPhaseAngle));
    private double requiredCurrent = 0;
    private int excitationField = 20; // Tesla

    public PowerGenerator(String componentId, ComponentType componentType, PowerComponentStatus status,
                          LocalDate installationDate, LocalDate lastMaintenanceDate, PowerGridController controller,
                          CircuitBreaker cb) {
        super(componentId, componentType, status, installationDate, lastMaintenanceDate);
        this.controller = controller;
        this.cb = cb;
    }

    public void startGenerator(String onOff){
        // before this operation must be checked if the generator is under load or not, once is started must be checked
        // the reactive power of load and in case is too low a bank of capacitors must be engaged. All this operations

        if (cb.checkCircuitStatus()){ // if contact off, generator is not under load, so can be verified all parameters
            if (operatingParametersValidation() && onOff.equals("on")){
                updateStatus(PowerComponentStatus.OPERATIONAL);
            }
        }

    }

    public void stopGenerator(String command){
        updateStatus(PowerComponentStatus.OFFLINE);
    }

    public void adjustOutput(int gridDemand){ // put here phiShift to consider engagement of supply transformers and
        // the need to rephase the machine via capacitors in parallel to the load line
        double powerOut = calculateGeneratedElectricPower(activePower, reactivePower, powerFactor);
        if (gridDemand > maxCapacity){
            cb.openCircuit();
            this.status = PowerComponentStatus.OFFLINE;
        }
        else {
            this.requiredCurrent = gridDemand/this.voltage;
            this.current = (int) requiredCurrent;
        }
    }

    public double calculateGeneratedElectricPower(double activePower, double reactivePower, double powerFactor){// notice, the voltage is referred to the phase voltage E, i.e
        // voltage generated by generator, not V - referred to voltage between each phase.

        double powerOutPut =  Math.sqrt(Math.pow(activePower,2) + Math.pow(reactivePower,2));
        return powerOutPut;
    }

    @Override
    public void addDateToMantainanceHist(LocalDate lastMaintenanceDate) {
        mantainanceHist.add(lastMaintenanceDate);
    }


    @Override
    public void performMantainance(TaskType taskType) {
        stopGenerator("off");
        cb.openCircuit();
        TaskStatus taskStatus = TaskStatus.IN_PROGRESS;
        this.status = PowerComponentStatus.OFFLINE;
    }

    @Override
    public double calculateEfficiency() {
        double Pout = calculateGeneratedElectricPower(activePower, reactivePower, powerFactor);
        double eff = Pout/Pin;
        return eff;
    }



    @Override
    protected boolean operatingParametersValidation() {
        if (this.voltage <= 25000 && requiredCurrent <= 18000){  // if current and voltage exceeds the maximal values
            // the component, no matter what is, will be isolated from the rest of the grid.
            return true;
        }
        return false;
    }


    public double getMaxCapacity() {
        return maxCapacity;
    }

    public void loadRephase(double powerFactor){
        this.powerFactor = powerFactorCorrected;
        this.activePower = 3 * (this.voltage * this.current * this.powerFactor);
        double newShiftPhaseAngle = Math.toDegrees(Math.acos(this.powerFactor));
        this.reactivePower = 3 * (this.voltage * this.current * Math.sin(newShiftPhaseAngle));
        double capacityPerPhase = this.reactivePower / 3 * 50 * Math.pow(this.voltage/Math.sqrt(3),2);

        // despite unuseful has been calculated the capacitance for each phase. The utility of this calculus comes
        // when in the project might be included a capacitors bank, hence, a group of capacitors are linked to the load
        // to achieve the phase capacity needed and reduce the load reactive power.
        // From a "coding" point of view the capacitors linking is a "manual" job, so must be included a method that opens a set of relay so that cpacitor bank is engaged.
    }

    public void connectGenToTheLoad(String operatorCommand){
        if (operatorCommand.equals("connect")){
            cb.closeCircuit(this.current);
        }
        boolean needPowFactCorr = false;
        if (powerFactor < 0.95){
            needPowFactCorr = true;
        }
        while (needPowFactCorr){

            loadRephase(powerFactor);
            break;
        }
    }

    public void setController(PowerGridController controller) {
        this.controller = controller;
    }

    public void setCb(CircuitBreaker cb) {
        this.cb = cb;
    }

    public int getExcitationField() {
        return excitationField;
    }

}
